# Go并发goroutine

通常，编写并发程序时最大的问题是在进程之间共享数据。 Go 采用不同于其他编程语言的通信方式，因为 Go 是通过 `channel` 来回传递数据的。 此方法意味着只有一个活动 (`goroutine`) 有权访问数据，设计上不存在争用条件。

Go 的方法可以总结为以下口号：“不是通过共享内存通信，而是**通过通信共享内存**。”

Golang 通过编译器运行时（Runtime），从语言上原生支持了并发编程。

## 并发与并行
学习 go 并发编程之前，我们需要弄清并发、并行的概念。

由于 CPU 同一时间只能执行一个进程/线程，在下文的概念中，我们把进程/线程统称为任务。不同的场景下，任务所指的可能是进程，也可能是线程。

### 并发（Concurrency）

并发是指计算机在同一时间段内执行多个任务。

并发的概念比较宽泛，它单纯是指计算机能够同时执行多个任务。比如我们当前是一个单核的 CPU，但是我们有5个任务，计算机会通过某种算法将 CPU 资源合理的分配给多个任务，从用户角度来看的话就是多个任务在同时执行。前面说的的算法比如“时间片轮转”。

### 并行（Parallelism）

并行是指在同一时刻执行多个任务。
当我们有多个核心的 CPU 的时候，我们同时执行两个任务，就不需要通过“时间片轮转”的方式让多个任务交替执行了，一个 CPU 负责一个任务，同一时刻，多个任务同时执行，这就是并行。

## 协程（Coroutine）

- 轻量级的线程：作用和线程差不多，都是并发执行一些任务的。
- 非抢占式多任务处理，即由协程主动交出控制权。这里需要了解一下抢占式和非抢占式的区别：

    - 抢占式：以线程为例，线程在任何时候都可能被操作系统进行切换，所以线程就叫做抢占式任务处理，即线程没有控制权，任务即使做到一半，哪怕没有做完，也会被操作系统给抢占了，然后切换到其他任务去。
    - 非抢占式：非抢占式的代表就是协程了，协程在任务做到一半的时候可以**主动的交出任务的控制权**，控制权是由协程内部决定，也正是因为这一特性，协程才是轻量级的。需要注意的是，当一个协程不主动交出控制权的时候，可能会造成死锁，也就是说控制权会一直在这个协程内部，程序将长时间等待，无法跳出。

- 编译器/解释器/虚拟机层面的多任务，**非操作系统层面**的，操作系统层面的多任务就只有进程/线程。
- 多个协程可能在一个或多个线程上运行，大多数情况下由调度器决定。
- 子程序（函数调用，比如 func a() {}）是协程的一个特例。

## Goroutine

goroutine 是轻量线程中的并发活动，而不是在操作系统中进行的传统活动

程序执行的第一个 goroutine 是 main() 函数。 如果要创建其他 goroutine，则必须在调用该函数之前使用 go 关键字
```GO
func main(){
    login()
    go func() {
        launch()
    }()
}
```